


# *Quiz questions*
>Q
\>>A
# 0x00


######

# 0x01


######

# 0x02


######

# 0x03


######

# 0x04


######

# 0x05
> Question #0

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

*p++;

402


0


\>> 98


99

> Question #1

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

402


0


\>> 98


99

> Question #2

What happens when one tries to access an illegal memory location?


There’s a chance for the computer to catch fire, and sometimes even explode


The operation is ignored


\>> Segmentation fault


The computer shuts down

> Question #3

Is it possible to declare a pointer to a pointer?


\>> Yes


No


It depends on the type the pointer is pointing to

> Question #4

The process of getting the value that is stored in the memory location pointed to by a pointer is called:


Casting


Pointing


Accessing


\>> Dereferencing

> Question #5

If we have a variable called var of type int, how can we get its address in memory?


*var


*(var)


\>> &var

> Question #6

What is the size of a pointer to an int (on a 64-bit architecture)


\>> 8 bytes


1 byte


2 bytes


4 bytes

> Question #7

We declare the following variable

int arr[5];
What is the size in memory of the variable arr?


\>> 20 bytes


4 bytes


5 bytes


32 bytes


10 bytes


8 bytes

> Question #8

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

*p = 402;

\>> 402


0


98


99

> Question #9

What is the size of a pointer to a char (on a 64-bit architecture)


\>> 8 bytes


1 byte


2 bytes


4 bytes

> Question #10

We declare the following variable

int arr[5];
What is the equivalent of typing arr[2]?


arr + 2


*arr + 2


\>> *(arr + 2)

> Question #11

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

p = 402;

402


0


\>> 98


99

> Question #12

What is the identifier to print an address with printf?


%x


%a


%d


\>> %p

######

# 0x06
> Question #0

What happens when one tries to dereference a pointer to NULL?


World War Z


Nothing


\>> Segmentation fault


Kernel panic

> Question #1

What is/are the difference(s) between the two following variables? (Except their names)

char *s1 = "";
char *s2 = NULL;

The second one can be dereferenced, not the first one


They are the same


\>> The first one points to a 0-byte, the second one points to 0


\>> The first one can be dereferenced, not the second one


The first one points to 0, the second one points to a 0-byte

> Question #2

Why is it important to reserve enough space for an extra character when declaring/allocating a string?


For fun


In case we need one


For memory alignment


\>> For the null byte (end of string)

> Question #3

What is wrong with the following code?

int n = 5;
int array[n];
int i = 3;

array[n] = i;

It is not possible to access array[n]


Nothing is wrong


\>> It is impossible to declare the variable array this way


The array array is not entirely initialized

> Question #4

What is wrong with the following code?

int n = 5;
int array[10];
int i = 3;

array[n] = i;

It is not possible to access array[n]


\>> Nothing is wrong


It is impossible to declare the variable array this way


The array array is not entirely initialized

> Question #5

var = "Best";
What is the type of var?


string


\>> char *


int *

> Question #6

What is wrong with the following code?

int n = 5;
int array[5];
int i = 3;

array[n] = i;

\>> It is not possible to access array[n]


Nothing is wrong


It is impossible to declare the variable array this way


The array array is not entirely initialized

######

# 0x07
> Question #0

What is the size of *p in this code?

int *p;

\>> 4 bytes


8 bytes


16 bytes

> Question #1

What is the size of *p in this code?

int **p;

4 bytes


\>> 8 bytes


16 bytes

> Question #2

In this following code, what is the value of a[1][1]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

\>> 4


1


2


3

> Question #3

In this following code, what is the value of a[3][1]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

\>> 8


7


9


{7, 8}

> Question #4

In this following code, what is the value of a[0][0]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

4


\>> 1


2


3

> Question #5

What is the size of p in this code?

int **p;

4 bytes


\>> 8 bytes


16 bytes

> Question #6

What is the size of p in this code?

int *p;

4 bytes


\>> 8 bytes


16 bytes

> Question #7

What is stored inside a pointer to a pointer to an int?


An address where an int is stored


An int


\>> An address where an address is stored

> Question #8

In this following code, what is the value of a[3][0]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

5


\>> 7


8


{7, 8}

######


# 0x08
> Question #0

What does this code print?

int print(int nb)
{
    if (nb < 0) 
    {
        return (0);
    }
    printf("%d", nb + print(nb - 1));
    nb --;
    return (nb);
}

int main(void)
{
    print(4);
    return (0);
}

64200


\>> 00246


01234568

> Question #1

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    nb ++;
    if (nb < 10) 
    {
        print(nb);
    }
}

int main(void)
{
    print(4);
    return (0);
}

\>> 456789


987654


109876543


345678910

> Question #2

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    -- nb;
    if (nb > 0) 
    {
        print(nb);
    }
}

int main(void)
{
    print(4);
    return (0);
}

3210


\>> 4321


43210


321

> Question #3

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    nb --;
    if (nb > 0) 
    {
        print(nb);
    }
}

int main(void)
{
    print(2);
    return (0);
}

210


012


12


\>> 21

> Question #4

What does this code print?

void print(int nb)
{
    if (nb < 0) 
    {
        return;
    }
    printf("%d", nb);
    nb --;
    print(nb);
}

int main(void)
{
    print(4);
    return (0);
}

4321


01234


\>> 43210


1234
######

# 0x09 

>Question #0

What command(s) can be used to list the symbols stored in a static library?


ld


\>>nm

ranlib


\>>ar

>Question #1

What is the point of using ranlib?


List the content of a library


Creating an archive


\>>Indexing an archive


Create a library from a simple archive

>Question #2

What command is used to create a static library from object files?


nm


gcc


ld


\>>ar


ranlib

>Question #3

What is the format of a static library?


\>>An archive


A relocatable ELF file


An executable ELF file


A shared ELF file
######

######

# 0xA
> Question #0

In the following command, what is argv[2]?

$ ./argv "My School is fun"

is


fun


\>> NULL


My School


My School is fun


./argv


is fun


School


My

> Question #1

In the following command, what is argv[2]?

$ ./argv "My School" "is fun"

is


fun


NULL


My School


My School is fun


./argv


\>> is fun


School


My

> Question #2

In the following command, what is argv[2]?

$ ./argv My School is fun

is


fun


NULL


My School


My School is fun


./argv


is fun


\>> School


My

> Question #3

What is argv[0]


> The program name


NULL


It does not always exist


The first command line argument

> Question #4

What is argv?


An array containing the program compilation flags


\>> An array containing the program command line arguments


\>> An array of size argc

> Question #5

What is argc?


The length of the first command line argument


\>>The number of command line arguments


A flag set to 1 when command line arguments are present


\>>The size of the argv array

> Question #6

What is argv[argc]?


The last command line argument


\>>NULL


It does not always exist


The program name


The first command line argument

######

# 0xB
> Question #0

How many bytes will this statement allocate?

malloc((sizeof(char) * 10) + 1)


\>> 11


1


10


20


21

> Question #1

How many bytes will this statement allocate?

malloc(10)


40


2


\>> 10


4

> Question #2

How many bytes will this statement allocate?

malloc(sizeof(char) * 10)


\>> 10


20


40

> Question #3

How many bytes will this statement allocate?

malloc(sizeof(int) * 10)


\>> 40


32


10

> Question #4

How many bytes will this statement allocate?

malloc(sizeof(int) * 4)


32


4


8


\>> 16

> Question #5

What is Valgrind?


It’s a program to test a C program in a specific environment


A container service


\>> It’s a program to validate memory allocation


It’s a new step when I compile with gcc

> Question #6

How many bytes will this statement allocate?

malloc(sizeof(unsigned int) * 2)


2


4


\>> 8

######

# 0xC
>Question #0

You can do this:

char *s;

s = strdup("Best School");
if (s != NULL)
{
    free(s);
}

No


\>>Yes

>Question #1

You can do this:

char str[] = "Best School";

free (str);

\>>No


Yes

>Question #2

You can do this:

free("Best School");

\>>No


Yes

>Question #3

What is wrong with this code:



int cp(void)
{
    char *s;

    s = malloc(12);
    strcpy(s, "Best School");
    return (0);
}

\>>malloc can fail so we should check its return value all the time before using the pointers returned by the function.


You don’t have enough space to store the copy of the string “Best School”


\>>There is no comment


You can’t call strcpy with a string literal

>Question #4

malloc returns a pointer


False


\>True

Question #5

If I want to copy the string “Best School” into a new space in memory, I can use this statement to reserve enough space for it (select all valid answers):


\>>malloc(strlen(“Best School”) + 1)


\>>malloc(sizeof(“Best School”))


malloc(strlen(“Best School”))


malloc(sizeof(“Best School”) + 1)


\>>malloc(12)


malloc(11)

>Question #6

What will you see on the terminal?

int main(void)
{
    int *ptr;

    *ptr = 98;
    printf("%d\n", *ptr);
    return (0);
}

\>>Segmentation Fault


0


98


It doesn’t compile

>Question #7

To allocate enough space for an array of 10 integers (on a 64bit, Linux machine), I can use:


malloc(64 * 10)


malloc(10 * int)


\>>malloc(10 * sizeof(int))

>Question #8

The memory space reserved when calling malloc is on:


\>>The heap


The stack

>Question #9

malloc returns an address


False


\>>True

######
######

######
# 0xD
> Question #0

What does the macro TABLESIZE expand to?

#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37

1020


\>>> 37


nothing

> Question #1

NULL is a macro


False


\>> True

> Question #2

What is the gcc option that runs only the preprocessor?


\>>>   -E


-a


-preprocessor


-P


-cisfun


-pedantic


-p

> Question #3

The preprocessor removes all comments


False


\>>> True

> Question #4

This portion of code is actually using the library stdlib.

#include <stdlib.h>

\>> False


True

> Question #5

The preprocessor generates object code


\>> False


True

> Question #6

The preprocessor generates assembly code


\>> False


True

> Question #7

This is the correct way to define the macro SUB:
#define SUB(a, b) a - b

\>> No, it should be written this way:
#define SUB(a, b) ((a) - (b))

Yes


No, it should be written this way:
#define SUB(a, b) (a - b)

No, it should be written this way:
#define SUB(a, b) (a) - (b)

> Question #8

The macro __FILE__ expands to the name of the current input file, in the form of a C string constant.


False


\>> True

> Question #9

This code will try to allocate 1024 bytes in the heap:

#define BUFFER_SIZE 1024
malloc(BUFFER_SIZE)

False


\>> True

> . Question #10

What will be the output of this program? (on a standard 64 bits, Linux machine)

#include <stdio.h>
#include <stdlib.h>

#define int char

int main(void)
{
    int i;

    i = 5;
    printf ("sizeof(i) = %lu", sizeof(i));
    return (EXIT_SUCCESS);
}

\>> sizeof(i) = 1


Segmentation Fault


It does not compile


sizeof(i) = 4


sizeof(i) = 5


sizeof(i) = 8

> . Question #11

What are the steps of compilation?


compiler 2. preprocessor 3. assembler 4. linker

\>> preprocessor 2.compiler 3. assembler 4. linker

preprocessor 2.compiler 3. linker 4. assembler
> Question #12

Why should we use include guards in our header files?


\>> To avoid the problem of double inclusion when dealing with the include directive.


Because we said so, and we should never ask why.

> Question #13

What will be the last 5 lines of the output of the command gcc -E on this code?

#include <stdlib.h>

int main(void)
{
    NULL;
    return (EXIT_SUCCESS);
}

int main(void)
{
 '\0';
 return (0);
}

int main(void)
{
 0;
 return (0);
}

int main()
{
 0;
 return (0);
}

\>> int main(void)
{
 ((void *)0);
 return (0);
}
> Question #14

The preprocessor links our code with libraries.


\>> False


True

######
######
# 0xE
> Question #0

Those two codes do the same thing:

typedef struct point point;
struct point {
   int    x;
   int    y;
};
point p = {1, 2};
typedef struct point point;
struct point {
   int    x;
   int    y;
};
point p = { .y = 2, .x = 1 };

\>> True


False: the second does not compile


False: the members of the structures will not have the same values

> Question #1

The general syntax for a struct declaration in C is:

struct tag_name {
   type member1;
   type member2;
   /* declare as many members as desired, but the entire structure size must be known to the compiler. */
};

\>> True


False


Maybe

> Question #2

You should write documentation for all the structures you create


\>> True


I’ll do it 5 minutes before the deadline when I try Betty on my header file


\>> As soon as I write my structure.

> Question #3

Given this code:

struct point {
   int x;
   int y;
};
struct point my_point = { 3, 7 };
struct point *p = &my_point;
To set the member y of my variable my_point to 98, I can do (select all valid answers):


\>> p->y = 98;


\>> my_point.y = 98;


my_point->y = 98;


\>> (*p).y = 98;


p.y = 98;

######
######
# 0x10


######


######

######
# 0x10


######



######

######
# 0x10


######


######

######
# 0x10


######


######

######
# 0x10


######



*THE END*