
# how to::
##########################################
Title
#############################
title2
##################
# *Quiz questions*
>Q
\>>A
##################
######
# 0x10


######

######

######
# 0x10


######



#########################################
System engin. DevOps
#############################
shell
##################
######
# 0x10


######


##################
vi
##################
######
# 0x10


######
##################
git
##################
######
# 0x10


######


#########################################
System engin. DevOps
#############################
shell
##################
######
# 0x0


######

######
# 0x1


######

######
# 0x2


######

######
# 0x3


######



##########################################
low level prog. lng.
#############################
c programming lang.
##################
# 0x00
> Question #0

What are the different steps to form an executable file from C source code


Preprocessing and compilation


Interpretation, compilation and assembly


\>>> Preprocessing, compilation, assembly, and linking


Compilation and linking


Interpretation, assembly and compilation

> Question #1

Which of the following are both valid comment syntaxes in ANSI C, and Betty-compliant?


/* Comment /* nested */ */

\>>>>>> 1
/* Comment */

// Comment

# Comment

\>>>>> 2
/*
 * Comment
 */

/*
Comment
*/
> Question #2

What is the common extension for a C header file?


.ch


.header


.hpp


\>>> .h

> Question #3

What is the common extension for a C source file?


.py


.txt


\>>> .c


.cpp

> Question #4

In which category belongs the C programming language?


\>> Compiled language


Interpreted language

> Question #5

Which command can be used to compile a C source file?


c-compiler


\>> gcc


bash



######

# 0x01
> Question #0

Which of the following are valid while or do/while statements in ANSI C and Betty-compliant? (Considering a and b two variables of type int)

Please select all correct answers


a = 0;
do while (a < b)
{
    printf("%d\n", a);
    a++;
}

while (a = 0; a < b; a++)
{
    printf("%d\n", a);
}

\>>> a = 0;
while (a < b)
{
    printf("%d\n", a);
    a++;
}

a = 0;
while (a < b)
(
    printf("%d\n", a);
    a++;
)

\>>> a = 0;
while (a < b)
    printf("%d\n", a++);

\>>> a = 0;
do {
    printf("%d\n", a);
    a++;
} while (a < b);


>Question #1

Which of the following are valid for statements in ANSI C and Betty-compliant? (Considering a and b two variables of type int)

Please select all correct answers


\>>> a = 0;
for (; a < b;)
{
    printf("%d\n", a++);
}

\>>> for (a = 0; a < b; a++)
{
    printf("%d\n", a);
}

\>>> for (a = 0; a < b; a++)
    printf("%d\n", a);

a = 0;
for (a < b;;)
{
    printf("%d\n", a++);
}

for (int a = 0; a < b; a++)
{
    printf("%d\n", a);
}
Question #2

What is the size of the float data type?


8 bytes


1 byte


2 bytes


\>> 4 bytes

> Question #3

What is the size of the char data type?


8 bytes


\>> 1 byte


2 bytes


4 bytes

> Question #4

What is the size of the unsigned int data type?


8 bytes


1 byte


2 bytes


\>> 4 bytes

> Question #5

Which of the following are valid if statements in ANSI C and Betty-compliant? (Considering a and b two variables of type int)

Please select all correct answers


\>>> if (a > b)
  return (a);

if a > b
{
  return (a);
}

\>>> if (a > b)
{
  return (a);
}

if ((((((a > b))))))
{
  return (a);
}

if {a > b}
(
  return {a};
)

######

# 0x02
> Question #0

What is the result of 89 % 7?


\>> 5


0


2


3

> Question #1

What is the result of 12 % 2?


\>> 0


1


2

> Question #2

What is the ASCII value of 5?


50


\>> 53


5

> Question #3

What is the ASCII value of -?


\>> 45


3


47

> Question #4

What is the ASCII value of 0?


79


0


\>> 48

> Question #5

What is the ASCII value of a?


1


\>> 97


65


12

> Question #6

What is the ASCII value of A?


1


97


\>> 65


12

> Question #7

What is the result of 12 % 10?


3


0


1


\>> 2

> Question #8

Which of these loop statements don’t exist?


\>> each


for


while


\>> loop_to


do... while


\>> foreach

> Question #9

What is the result of 12 % 3?


3


\>> 0


1


2

>Question #10

What is the ASCII value of J?


76


70


72


\>> 74

######

# 0x03
>Question #0

The following code gives this output. What is the error?

carrie@ubuntu:/debugging$ cat main.c                                
>#include <stdio.h>                                                                                  

/**                                                                                                 
 * main - debugging example                                                                         
 * Return: 0                                                                                        
 */                                                                                                 
int main(void)                                                                                      
{                                                                                                   
        int i;                                                                                      
        int j;                                                                                      
        int k;                                                                                      

        i = 0;                                                                                      
        j = 1000;                                                                                   
        while (i < j)                                                                               
        {                                                                                           
                k = j / 98;                                                                         
                i = i + k;                                                                          
                printf("%d\n", i);                                                                  
                j == j - 1;                                                                         
        }                                                                                           

        return (0);                                                                                 
}                                                                                                   
carrie@ubuntu:/debugging$
carrie@ubuntu:/debugging$ gcc -Wall -Werror -Wextra -pedantic main.
c                                                                                                   
main.c: In function ‘main’:                                                                         
main.c:20:3: error: statement with no effect [-Werror=unused-value]                                 
   j == j - 1;                                                                                      
   ^                                                                                                
cc1: all warnings being treated as errors                                                           
carrie@ubuntu:/debugging$

We don’t need to assign a new value to j because it doesn’t do anything


\>> We want to assign j a new value, not compare it, so it should be j = j - 1 instead of j == j - 1


We want to compare j so we need an if statement before j == j - 1

> Question #1

The following code gives this incorrect output. Which of the following statements about what is causing the error is true?

carrie@ubuntu:/debugging$ cat main.c                               
#include <stdio.h>                                                                                 

/**                                                                                                
 * main - debugging example                                                                        
 * Return: 0                                                                                       
 */                                                                                                
int main(void)                                                                                     
{                                                                                                  
        int i;                                                                                     
        int j;                                                                                     

        for (i = 0; i < 10; i++)                                                                   
        {                                                                                          
                j = 0;                                                                             
                while (j < 10)                                                                     
                {                                                                                  
                        printf("%d", j);                                                           
                }                                                                                  
                printf("\n");                                                                      
        }                                                                                          

        return (0);                                                                                
}                                                                                                  
carrie@ubuntu:/debugging$
carrie@ubuntu:/debugging$ gcc -Wall -Werror -Wextra -pedantic main.c                                                                                                  
carrie@ubuntu:/debugging$ ./a.out
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 <...>
^Ccarrie@ubuntu:/debugging$

\>>> j never increments so it will always be less than 10


j is always equal to i so the loop will never end


\>>> j never increments so it is always going to print 0

> Question #2

Look at the following code.

carrie@ubuntu:/debugging$ cat main.c                                
#include <stdio.h>                                                                                  

/**                                                                                                 
 * main - debugging example                                                                         
 * Return: 0                                                                                        
 */                                                                                                 
int main(void)                                                                                      
{                                                                                                   
        char *hello = "Hello, World!";                                                              

        for (i = 0; hello[i] != '\0'; i++)                                                          
        {                                                                                           
                printf("%c", hello[i]);                                                             
        }                                                                                           

        printf("\n");                                                                               

        return (0);                                                                                 
}                                                                                                   
carrie@ubuntu:/debugging$
carrie@ubuntu:/debugging$ gcc -Wall -Werror -Wextra -pedantic main.
c                                                                                                   
main.c: In function ‘main’:                                                                         
main.c:11:7: error: ‘i’ undeclared (first use in this function)                                     
  for (i = 0; hello[i] != '\0'; i++)                                                                
       ^                                                                                            
main.c:11:7: note: each undeclared identifier is reported only once for each function it appears in
main.c:9:8: error: variable ‘hello’ set but not used [-Werror=unused-but-set-variable]              
  char *hello = "Hello, World!";                                                                    
        ^                                                                                           
cc1: all warnings being treated as errors                                                           
carrie@ubuntu:/debugging$                         
In the main.c file, on what line is the first error that the compiler returns?


9


\>>> 11


7

Tips:

You do not have to know exactly what this code does yet (but you will soon!).
>Question #3

This code doesn’t work as intended.

>#include "main.h"

/**
* main - prints even numbers from 0 to 100
* Return: 0
*/

int main(void)
{
        int i;

        for (i = 0; i < 100; i++)
        {
                if (i % 2 != 0)
                {
                        continue;
                }
                else
                {
                        break;
                }

                printf("%d\n", i);
        }

        return(0);
}
Let’s add printf statements to the code. What information do the printf statements tell us about how our code is executed?

>#include "main.h"

/**
* main - prints even numbers from 0 to 100
* Return: 0
*/

int main(void)
{
        int i;

        printf("Before loop\n");

        for (i = 0; i < 100; i++)
        {
                if (i % 2 != 0)
                {
                        printf("i is not even so don't print\n");
                        continue;
                }
                else
                {
                        printf("i is even, break to print\n");
                        break;
                }

                printf("Outside of if/else, still inside for loop\n");

                printf("%d\n", i);
        }

        printf("For loop exited\n");

        return(0);
}

A printf statement shows that there is an infinite loop in the code


\>>> A printf statement shows when the for loop is finished


A printf statement shows exactly how many times the loop executes


\>>> printf statements shows that break will cause “For loop exited” to print, indicating that the even number is never printed

######

# 0x04
> Question #0

What is the return value of the following function?

int some_function(void)
{
    printf("%d", 12);
    return (98);
}

12


\>>> 98


402

> Question #1

What is the output of the following piece of code?

int i;

i = 9;
while (--i)
{
    printf("%d", i);
}

987654321


\>> 87654321


9876543210


876543210

> Question #2

What is the output of the following piece of code?

int i;

i = 9;
while (i--)
{
    printf("%d", i);
}

987654321


87654321


\>> 876543210


9876543210

> Question #3

What is the output of the following piece of code?

int i;

i = -9;
while (i < 0)
{
    printf("%d", -i);
    i++;
}

-9-8-7-6-5-4-3-2-1


9876543210


\>> 987654321


-9-8-7-6-5-4-3-2-10

> Question #4

What is the output of the following piece of code?

int i;

for (i = 0; i < 10; i++)
{
    printf("%d", i * 2);
}

0123456789


2468101214161820


\>> 024681012141618

> Question #5

What is the output of the following piece of code?

int i;

i = 0;
while (i < 10)
{
    printf("%d", i % 2);
    i++;
}

\>> 0101010101


0123456789


1010101010

> Question #6

What is the output of the following piece of code?

int i;

for (i = 48; i < 58; i++)
{
    printf("%c", i);
}

48495051525354555657


\>> 0123456789


School

> Question #7

What is the return value of the following function?

int some_function(void)
{
    int i;

    for (i = 0; i < 10; i++)
    {
        printf("%d", i);
    }
    return(i);
}

0123456789


0


9


\>> 10

> Question #8

What is the output of the following piece of code?

int i;

i = 0;
while (i < 10)
{
    i++;
    printf("%d", i / 2);
}

0011223344


0123456789


\>> 0112233445



######

# 0x05
> Question #0

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

*p++;

402


0


\>> 98


99

> Question #1

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

402


0


\>> 98


99

> Question #2

What happens when one tries to access an illegal memory location?


There’s a chance for the computer to catch fire, and sometimes even explode


The operation is ignored


\>> Segmentation fault


The computer shuts down

> Question #3

Is it possible to declare a pointer to a pointer?


\>> Yes


No


It depends on the type the pointer is pointing to

> Question #4

The process of getting the value that is stored in the memory location pointed to by a pointer is called:


Casting


Pointing


Accessing


\>> Dereferencing

> Question #5

If we have a variable called var of type int, how can we get its address in memory?


*var


*(var)


\>> &var

> Question #6

What is the size of a pointer to an int (on a 64-bit architecture)


\>> 8 bytes


1 byte


2 bytes


4 bytes

> Question #7

We declare the following variable

int arr[5];
What is the size in memory of the variable arr?


\>> 20 bytes


4 bytes


5 bytes


32 bytes


10 bytes


8 bytes

> Question #8

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

*p = 402;

\>> 402


0


98


99

> Question #9

What is the size of a pointer to a char (on a 64-bit architecture)


\>> 8 bytes


1 byte


2 bytes


4 bytes

> Question #10

We declare the following variable

int arr[5];
What is the equivalent of typing arr[2]?


arr + 2


*arr + 2


\>> *(arr + 2)

> Question #11

What is the value of n after the following code is executed?

int n = 98;
int *p = &n;

p = 402;

402


0


\>> 98


99

> Question #12

What is the identifier to print an address with printf?


%x


%a


%d


\>> %p

######

# 0x06
> Question #0

What happens when one tries to dereference a pointer to NULL?


World War Z


Nothing


\>> Segmentation fault


Kernel panic

> Question #1

What is/are the difference(s) between the two following variables? (Except their names)

char *s1 = "";
char *s2 = NULL;

The second one can be dereferenced, not the first one


They are the same


\>> The first one points to a 0-byte, the second one points to 0


\>> The first one can be dereferenced, not the second one


The first one points to 0, the second one points to a 0-byte

> Question #2

Why is it important to reserve enough space for an extra character when declaring/allocating a string?


For fun


In case we need one


For memory alignment


\>> For the null byte (end of string)

> Question #3

What is wrong with the following code?

int n = 5;
int array[n];
int i = 3;

array[n] = i;

It is not possible to access array[n]


Nothing is wrong


\>> It is impossible to declare the variable array this way


The array array is not entirely initialized

> Question #4

What is wrong with the following code?

int n = 5;
int array[10];
int i = 3;

array[n] = i;

It is not possible to access array[n]


\>> Nothing is wrong


It is impossible to declare the variable array this way


The array array is not entirely initialized

> Question #5

var = "Best";
What is the type of var?


string


\>> char *


int *

> Question #6

What is wrong with the following code?

int n = 5;
int array[5];
int i = 3;

array[n] = i;

\>> It is not possible to access array[n]


Nothing is wrong


It is impossible to declare the variable array this way


The array array is not entirely initialized

######

# 0x07
> Question #0

What is the size of *p in this code?

int *p;

\>> 4 bytes


8 bytes


16 bytes

> Question #1

What is the size of *p in this code?

int **p;

4 bytes


\>> 8 bytes


16 bytes

> Question #2

In this following code, what is the value of a[1][1]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

\>> 4


1


2


3

> Question #3

In this following code, what is the value of a[3][1]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

\>> 8


7


9


{7, 8}

> Question #4

In this following code, what is the value of a[0][0]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

4


\>> 1


2


3

> Question #5

What is the size of p in this code?

int **p;

4 bytes


\>> 8 bytes


16 bytes

> Question #6

What is the size of p in this code?

int *p;

4 bytes


\>> 8 bytes


16 bytes

> Question #7

What is stored inside a pointer to a pointer to an int?


An address where an int is stored


An int


\>> An address where an address is stored

> Question #8

In this following code, what is the value of a[3][0]?

int a[5][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

5


\>> 7


8


{7, 8}

######


# 0x08
> Question #0

What does this code print?

int print(int nb)
{
    if (nb < 0) 
    {
        return (0);
    }
    printf("%d", nb + print(nb - 1));
    nb --;
    return (nb);
}

int main(void)
{
    print(4);
    return (0);
}

64200


\>> 00246


01234568

> Question #1

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    nb ++;
    if (nb < 10) 
    {
        print(nb);
    }
}

int main(void)
{
    print(4);
    return (0);
}

\>> 456789


987654


109876543


345678910

> Question #2

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    -- nb;
    if (nb > 0) 
    {
        print(nb);
    }
}

int main(void)
{
    print(4);
    return (0);
}

3210


\>> 4321


43210


321

> Question #3

What does this code print?

void print(int nb)
{
    printf("%d", nb);
    nb --;
    if (nb > 0) 
    {
        print(nb);
    }
}

int main(void)
{
    print(2);
    return (0);
}

210


012


12


\>> 21

> Question #4

What does this code print?

void print(int nb)
{
    if (nb < 0) 
    {
        return;
    }
    printf("%d", nb);
    nb --;
    print(nb);
}

int main(void)
{
    print(4);
    return (0);
}

4321


01234


\>> 43210


1234
######

# 0x09 

>Question #0

What command(s) can be used to list the symbols stored in a static library?


ld


\>>nm

ranlib


\>>ar

>Question #1

What is the point of using ranlib?


List the content of a library


Creating an archive


\>>Indexing an archive


Create a library from a simple archive

>Question #2

What command is used to create a static library from object files?


nm


gcc


ld


\>>ar


ranlib

>Question #3

What is the format of a static library?


\>>An archive


A relocatable ELF file


An executable ELF file


A shared ELF file
######

######

# 0xA
> Question #0

In the following command, what is argv[2]?

$ ./argv "My School is fun"

is


fun


\>> NULL


My School


My School is fun


./argv


is fun


School


My

> Question #1

In the following command, what is argv[2]?

$ ./argv "My School" "is fun"

is


fun


NULL


My School


My School is fun


./argv


\>> is fun


School


My

> Question #2

In the following command, what is argv[2]?

$ ./argv My School is fun

is


fun


NULL


My School


My School is fun


./argv


is fun


\>> School


My

> Question #3

What is argv[0]


> The program name


NULL


It does not always exist


The first command line argument

> Question #4

What is argv?


An array containing the program compilation flags


\>> An array containing the program command line arguments


\>> An array of size argc

> Question #5

What is argc?


The length of the first command line argument


\>>The number of command line arguments


A flag set to 1 when command line arguments are present


\>>The size of the argv array

> Question #6

What is argv[argc]?


The last command line argument


\>>NULL


It does not always exist


The program name


The first command line argument

######

# 0xB
> Question #0

How many bytes will this statement allocate?

malloc((sizeof(char) * 10) + 1)


\>> 11


1


10


20


21

> Question #1

How many bytes will this statement allocate?

malloc(10)


40


2


\>> 10


4

> Question #2

How many bytes will this statement allocate?

malloc(sizeof(char) * 10)


\>> 10


20


40

> Question #3

How many bytes will this statement allocate?

malloc(sizeof(int) * 10)


\>> 40


32


10

> Question #4

How many bytes will this statement allocate?

malloc(sizeof(int) * 4)


32


4


8


\>> 16

> Question #5

What is Valgrind?


It’s a program to test a C program in a specific environment


A container service


\>> It’s a program to validate memory allocation


It’s a new step when I compile with gcc

> Question #6

How many bytes will this statement allocate?

malloc(sizeof(unsigned int) * 2)


2


4


\>> 8

######

# 0xC
>Question #0

You can do this:

char *s;

s = strdup("Best School");
if (s != NULL)
{
    free(s);
}

No


\>>Yes

>Question #1

You can do this:

char str[] = "Best School";

free (str);

\>>No


Yes

>Question #2

You can do this:

free("Best School");

\>>No


Yes

>Question #3

What is wrong with this code:



int cp(void)
{
    char *s;

    s = malloc(12);
    strcpy(s, "Best School");
    return (0);
}

\>>malloc can fail so we should check its return value all the time before using the pointers returned by the function.


You don’t have enough space to store the copy of the string “Best School”


\>>There is no comment


You can’t call strcpy with a string literal

>Question #4

malloc returns a pointer


False


\>True

Question #5

If I want to copy the string “Best School” into a new space in memory, I can use this statement to reserve enough space for it (select all valid answers):


\>>malloc(strlen(“Best School”) + 1)


\>>malloc(sizeof(“Best School”))


malloc(strlen(“Best School”))


malloc(sizeof(“Best School”) + 1)


\>>malloc(12)


malloc(11)

>Question #6

What will you see on the terminal?

int main(void)
{
    int *ptr;

    *ptr = 98;
    printf("%d\n", *ptr);
    return (0);
}

\>>Segmentation Fault


0


98


It doesn’t compile

>Question #7

To allocate enough space for an array of 10 integers (on a 64bit, Linux machine), I can use:


malloc(64 * 10)


malloc(10 * int)


\>>malloc(10 * sizeof(int))

>Question #8

The memory space reserved when calling malloc is on:


\>>The heap


The stack

>Question #9

malloc returns an address


False


\>>True

######
######

######
# 0xD
> Question #0

What does the macro TABLESIZE expand to?

#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37

1020


\>>> 37


nothing

> Question #1

NULL is a macro


False


\>> True

> Question #2

What is the gcc option that runs only the preprocessor?


\>>>   -E


-a


-preprocessor


-P


-cisfun


-pedantic


-p

> Question #3

The preprocessor removes all comments


False


\>>> True

> Question #4

This portion of code is actually using the library stdlib.

#include <stdlib.h>

\>> False


True

> Question #5

The preprocessor generates object code


\>> False


True

> Question #6

The preprocessor generates assembly code


\>> False


True

> Question #7

This is the correct way to define the macro SUB:
#define SUB(a, b) a - b

\>> No, it should be written this way:
#define SUB(a, b) ((a) - (b))

Yes


No, it should be written this way:
#define SUB(a, b) (a - b)

No, it should be written this way:
#define SUB(a, b) (a) - (b)

> Question #8

The macro __FILE__ expands to the name of the current input file, in the form of a C string constant.


False


\>> True

> Question #9

This code will try to allocate 1024 bytes in the heap:

#define BUFFER_SIZE 1024
malloc(BUFFER_SIZE)

False


\>> True

> . Question #10

What will be the output of this program? (on a standard 64 bits, Linux machine)

#include <stdio.h>
#include <stdlib.h>

#define int char

int main(void)
{
    int i;

    i = 5;
    printf ("sizeof(i) = %lu", sizeof(i));
    return (EXIT_SUCCESS);
}

\>> sizeof(i) = 1


Segmentation Fault


It does not compile


sizeof(i) = 4


sizeof(i) = 5


sizeof(i) = 8

> . Question #11

What are the steps of compilation?


compiler 2. preprocessor 3. assembler 4. linker

\>> preprocessor 2.compiler 3. assembler 4. linker

preprocessor 2.compiler 3. linker 4. assembler
> Question #12

Why should we use include guards in our header files?


\>> To avoid the problem of double inclusion when dealing with the include directive.


Because we said so, and we should never ask why.

> Question #13

What will be the last 5 lines of the output of the command gcc -E on this code?

#include <stdlib.h>

int main(void)
{
    NULL;
    return (EXIT_SUCCESS);
}

int main(void)
{
 '\0';
 return (0);
}

int main(void)
{
 0;
 return (0);
}

int main()
{
 0;
 return (0);
}

\>> int main(void)
{
 ((void *)0);
 return (0);
}
> Question #14

The preprocessor links our code with libraries.


\>> False


True

######
######
# 0xE
> Question #0

Those two codes do the same thing:

typedef struct point point;
struct point {
   int    x;
   int    y;
};
point p = {1, 2};
typedef struct point point;
struct point {
   int    x;
   int    y;
};
point p = { .y = 2, .x = 1 };

\>> True


False: the second does not compile


False: the members of the structures will not have the same values

> Question #1

The general syntax for a struct declaration in C is:

struct tag_name {
   type member1;
   type member2;
   /* declare as many members as desired, but the entire structure size must be known to the compiler. */
};

\>> True


False


Maybe

> Question #2

You should write documentation for all the structures you create


\>> True


I’ll do it 5 minutes before the deadline when I try Betty on my header file


\>> As soon as I write my structure.

> Question #3

Given this code:

struct point {
   int x;
   int y;
};
struct point my_point = { 3, 7 };
struct point *p = &my_point;
To set the member y of my variable my_point to 98, I can do (select all valid answers):


\>> p->y = 98;


\>> my_point.y = 98;


my_point->y = 98;


\>> (*p).y = 98;


p.y = 98;

######
######
# 0xF

> Question #0

What does a pointer to a function point to (check all correct answers if there is more than one)?


\>>> The first byte of code of the function


data


\>>> code


The first character of the name of the function

> Question #1

If f is a pointer to a function that takes no parameter and returns an int, you can call the function pointed by f this way (check all correct answers if there is more than one):


\>>> f();


\>>> (*f)();


f;

> Question #2

To store the address of this function:

void neyo(void);
to the variable f of type pointer to a function that does not take any argument and does not return anything, you would do (check all correct answers if there is more than one):


*f = &neyo;


\>>> f = neyo;


\>>> f = &neyo;


*f = neyo;

> Question #3

Which one is a pointer to a function?


(int *)func(int a, float b);


int func(int a, float b);


int *func(int a, float b);


\>> int (*func)(int a, float b);

> Question #4

This void (*anjula[])(int, float) is:


A pointer to an array of functions that take an int and a float as parameters and returns nothing


A pointer to a function that takes an int and a float as parameters and returns nothing


A pointer to a function that takes an array of int and float as a parameter and returns nothing


\>>> An array of pointers to functions that take an int and a float as parameters and returns nothing


A pointer to a function that takes an int and a float as parameters and returns an empty array


######


######

######
# 0x12
######


> Question #0

Arrays Vs Linked Lists: select all true statements


We can easily remove an element from an Array


\\>>> We can add elements indefinitely to a linked list


\\>>> We can easily removed an element from a Linked list


\\>>> Memory is aligned for an Array - each elements are back to back in the memory


We can add elements indefinitely to an array


Memory is aligned for a Linked list - each elements are back to back in the memory


\\>>> Array can contain as value a structure


\\>>>  Linked list can contain as value a structure

> Question #1

What’s the “tail” of a linked list?


It’s the node with the lowest value


\>> It’s the node with the pointer to the next equals to NULL


It’s the first node


It’s the node with the highest value

> Question #2

What’s the “head” of a linked list?


It’s the node with the pointer to the next equals to NULL


It’s the last node


It’s the node with the highest value


It’s the node with the lowest value


\>> It’s the first node

> Question #3

What’s a node? (select all possible answers)


\>> It’s a space allocated in memory


It’s a server


\>> It’s a structure with a pointer to the next node and value information


It’s an integer


It’s a cell in an array

> Question #4

In a singly linked list, what are possible directions to traverse it? (select all possible answers)


Backward


\>> Forward







######

######
# 0x13


######


######

######
# 0x14


######


######

######
# 0x15


######



*THE END*